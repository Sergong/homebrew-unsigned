name: Update Unsigned Casks
on:
  schedule:
    - cron: "27 8 * * *" # Daily at 08:27 UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-casks:
    runs-on: macos-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure Homebrew Tap
        run: |
          # 1. Update Homebrew Core
          brew update

          # 2. Symlink this repo into Homebrew's internal Tap structure
          # This tricks Homebrew into accepting our local files as a valid "Installed Tap"
          TAP_NAME="${GITHUB_REPOSITORY}" # e.g. "yourname/homebrew-unsigned"
          TAP_DIR="$(brew --repo)/Library/Taps/$TAP_NAME"

          mkdir -p "$(dirname "$TAP_DIR")"
          # We symlink the current GitHub Action workspace ($PWD) to the Homebrew tap directory
          ln -s "$PWD" "$TAP_DIR"

          echo "Symlinked $PWD to $TAP_DIR"
          brew tap-info "$TAP_NAME"

      - name: Check and Update Casks
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          CASKS=("librewolf" "inkscape")
          TAP_PREFIX="${GITHUB_REPOSITORY}"

          git config user.name "Cask Bot"
          git config user.email "bot@noreply.github.com"

          for CASK_NAME in "${CASKS[@]}"; do
            echo "---------------------------------------------------"
            echo "Processing: $CASK_NAME"
            
            FULL_CASK_REF="${TAP_PREFIX}/${CASK_NAME}"
            LOCAL_FILE="Casks/${CASK_NAME}.rb"
            
            # 1. Check for Updates
            LATEST_VERSION=$(brew livecheck --cask --quiet --newer-only "$FULL_CASK_REF" | awk '{print $2}')

            if [ -z "$LATEST_VERSION" ]; then
              echo "  -> Up to date."
              continue
            fi
            
            echo "  -> Found new version: $LATEST_VERSION"

            # 2. Update Version in File
            sed -i '' "s/version \".*\"/version \"$LATEST_VERSION\"/" "$LOCAL_FILE"
            sed -i '' "s/sha256 \".*\"/sha256 :no_check/" "$LOCAL_FILE"

            # 3. Fetch and Calculate SHA (ROBUST METHOD)
            echo "  -> Fetching artifact..."
            
            # We fetch the file, but ask brew specifically for the location (path) of the downloaded file
            # This avoids parsing the human-readable text output for the hash
            DOWNLOAD_PATH=$(brew fetch --cask --force "$FULL_CASK_REF" | grep "Downloaded to:" | awk '{print $3}')
            
            # Fallback: if 'Downloaded to:' isn't found, try to find the cached file manually
            if [ -z "$DOWNLOAD_PATH" ]; then
               # If grep failed, try getting the path via `brew --cache`
               DOWNLOAD_PATH=$(brew --cache --cask "$FULL_CASK_REF")
            fi

            if [ ! -f "$DOWNLOAD_PATH" ]; then
              echo "  -> âŒ Fetch failed (File not found at $DOWNLOAD_PATH). Reverting."
              git checkout "$LOCAL_FILE"
              continue
            fi

            # Calculate SHA manually from the file on disk
            NEW_SHA=$(shasum -a 256 "$DOWNLOAD_PATH" | awk '{print $1}')
            echo "  -> Calculated SHA: $NEW_SHA"

            # 4. Finalize File
            sed -i '' "s/sha256 :no_check/sha256 \"$NEW_SHA\"/" "$LOCAL_FILE"
            # Redundant check for safety
            sed -i '' "s/sha256 \".*\"/sha256 \"$NEW_SHA\"/" "$LOCAL_FILE"

            # 5. Commit
            git add "$LOCAL_FILE"
            git commit -m "Update $CASK_NAME to $LATEST_VERSION"
          done

          # ---------------------------------------------------------
          # PUSH CHANGES (Fixed Logic)
          # ---------------------------------------------------------
          # Check if we are ahead of remote by looking for unpushed commits
          if [ -n "$(git cherry -v)" ]; then
            echo "Pushing changes..."
            git push
          else
            echo "No changes to push."
          fi
